\section{GoI for MELL: exponentials}\label{goi-for-mell-exponentials}

\subsection{The tensor product of Hilbert spaces}\label{the-tensor-product-of-hilbert-spaces}

Recall that we work in the Hilbert space \(H=\ell^2(\mathbb{N})\)
endowed with its canonical hilbertian basis denoted by
\((e_k)_{k\in\mathbb{N}}\).

The space \(H\tens H\) is the collection of sequences
\((x_{np})_{n,p\in\mathbb{N}}\) of complex numbers such that
\(\sum_{n,p}|x_{np}|^2\) converges. The scalar product is defined just
as before:

\begin{description}
\tightlist
\item[]
\(\langle (x_{np}), (y_{np})\rangle = \sum_{n,p} x_{np}\bar y_{np}\).
\end{description}

If \(x = (x_n)_{n\in\mathbb{N}}\) and \(y = (y_p)_{p\in\mathbb{N}}\) are
vectors in \(H\) then their tensor is the sequence:

\begin{description}
\tightlist
\item[]
\(x\tens y = (x_ny_p)_{n,p\in\mathbb{N}}\).
\end{description}

We define: \(e_{np} = e_n\tens e_p\) so that \(e_{np}\) is the sequence
\((e_{npij})_{i,j\in\mathbb{N}}\) of complex numbers given by
\(e_{npij} = \delta_{ni}\delta_{pj}\). By bilinearity of tensor we have:

\begin{description}
\tightlist
\item[]
x\textbackslash{}tens y = \textbackslash{}left(\textbackslash{}sum\_n
x\_ne\_n\textbackslash{}right)\textbackslash{}tens\textbackslash{}left(\textbackslash{}sum\_p
y\_pe\_p\textbackslash{}right) =
\end{description}

\texttt{~\textbackslash{}sum\_\{n,p\}~x\_ny\_p\textbackslash{},~e\_n\textbackslash{}tens~e\_p~=~\textbackslash{}sum\_\{n,p\}~x\_ny\_p\textbackslash{},e\_\{np\}}

Furthermore the system of vectors \((e_{np})\) is a hilbertian basis of
\(H\tens H\): the sequence \(x=(x_{np})_{n,p\in\mathbb{N}}\) may be
written:

\begin{description}
\tightlist
\item[]
x =
\textbackslash{}sum\_\{n,p\textbackslash{}in\textbackslash{}mathbb\{N\}\}x\_\{np\}\textbackslash{},e\_\{np\}
\end{description}

\texttt{~~~~~~~~~=~\textbackslash{}sum\_\{n,p\textbackslash{}in\textbackslash{}mathbb\{N\}\}x\_\{np\}\textbackslash{},e\_n\textbackslash{}tens~e\_p}\texttt{.}

\subsubsection{An algebra isomorphism}\label{an-algebra-isomorphism}

Being both separable Hilbert spaces, \(H\) and \(H\tens H\) are
isomorphic. We will now define explicitely an iso based on partial
permutations.

We fix, once for all, a bijection from couples of natural numbers to
natural numbers that we will denote by
\((n,p)\mapsto\langle n,p\rangle\). For example set
\(\langle n,p\rangle = 2^n(2p+1) - 1\). Conversely, given
\(n\in\mathbb{N}\) we denote by \(n_{(1)}\) and \(n_{(2)}\) the unique
integers such that \(\langle n_{(1)},
n_{(2)}\rangle = n\).

This bijection can be extended into a Hilbert space isomorphism
\(\Phi:H\tens H\rightarrow H\) by defining:

\begin{description}
\tightlist
\item[]
\(e_n\tens e_p = e_{np} \mapsto e_{\langle n,p\rangle}\).
\end{description}

Now given an operator \(u\) on \(H\) we define the operator \(!u\) on
\(H\) by:

\begin{description}
\tightlist
\item[]
\(!u(e_{\langle n,p\rangle}) = \Phi(e_n\tens u(e_p))\).
\end{description}

One can check that given two operators \(u\) and \(v\) we have:

\begin{itemize}
\tightlist
\item
  \(!u!v = {!(uv)}\);
\item
  \(!(u^*) = (!u)^*\).
\end{itemize}

Due to the fact that \(\Phi\) is an isomorphism \emph{onto} we also have
\(!1=1\); this however will not be used.

We therefore have that \(!\) is a morphism on \(\mathcal{B}(H)\); it is
easily seen to be an iso (not \emph{onto} though). As this is the
crucial ingredient for interpreting the structural rules of linear
logic, we will call it the \emph{copying iso}.

\subsubsection{Interpretation of
exponentials}\label{interpretation-of-exponentials}

If we suppose that \(u = u_\varphi\) is a \(p\)-isometry generated by
the partial permutation \(\varphi\) then we have:

\begin{description}
\tightlist
\item[]
\(!u(e_{\langle n,p\rangle}) = \Phi(e_n\tens u(e_p)) = \Phi(e_n\tens e_{\varphi(p)}) = e_{\langle n,\varphi(p)\rangle}\).
\end{description}

Thus \(!u_\varphi\) is itself a \(p\)-isometry generated by the partial
permutation
\(!\varphi:n\mapsto \langle n_{(1)}, \varphi(n_{(2)})\rangle\), which
shows that the proof space is stable under the copying iso.

Given a type \(A\) we define the type \(!A\) by:

\begin{description}
\tightlist
\item[]
\(!A = \{!u, u\in A\}\biorth\)
\end{description}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
